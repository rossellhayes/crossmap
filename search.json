[{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/ code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https:// www.contributor-covenant.org/translations.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Alexander Rossell Hayes Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Rossell Hayes. Author, maintainer, copyright holder.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rossell Hayes (2025). crossmap: Apply Functions Combinations List Elements. R package version 0.4.2, https://pkg.rossellhayes.com/crossmap.","code":"@Manual{,   title = {crossmap: Apply Functions to All Combinations of List Elements},   author = {Alexander {Rossell Hayes}},   year = {2025},   note = {R package version 0.4.2},   url = {https://pkg.rossellhayes.com/crossmap}, }"},{"path":"https://pkg.rossellhayes.com/crossmap/index.html","id":"crossmap-","dir":"","previous_headings":"","what":"Apply Functions to All Combinations of List Elements","title":"Apply Functions to All Combinations of List Elements","text":"crossmap provides extension purrr’s family mapping functions. xmap() works like purrr::pmap(), applies function every combination elements list inputs. crossmap also includes general purpose specialized functions working combinations list elements.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Apply Functions to All Combinations of List Elements","text":"can install released version crossmap CRAN : development version GitHub :","code":"install.packages(\"crossmap\") # install.packages(\"pak\") pak::pkg_install(\"rossellhayes/crossmap\")"},{"path":"https://pkg.rossellhayes.com/crossmap/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Apply Functions to All Combinations of List Elements","text":"purrr::pmap() applies function list elements pairwise, xmap() applies function combinations elements. xmap_mat() formats xmap() results matrix. crossmap also integrates furrr offer parallelized versions xmap() functions. cross_fit() easy wrapper important use crossmap, crossing model specifications different formulas, subsets, weights. cross_list() finds combinations elements set lists. cross_join() finds combinations rows data frames. map_vec() variants automatically determine output types. means don’t worry adding _int(), _dbl() _chr(). Hex sticker font Source Sans Adobe. Please note crossmap released Contributor Code Conduct.","code":"pmap_chr(list(1:3, 1:3), ~ paste(.x, \"*\", .y, \"=\", .x * .y)) #> [1] \"1 * 1 = 1\" \"2 * 2 = 4\" \"3 * 3 = 9\" xmap_chr(list(1:3, 1:3), ~ paste(.x, \"*\", .y, \"=\", .x * .y)) #> [1] \"1 * 1 = 1\" \"2 * 1 = 2\" \"3 * 1 = 3\" \"1 * 2 = 2\" \"2 * 2 = 4\" \"3 * 2 = 6\" #> [7] \"1 * 3 = 3\" \"2 * 3 = 6\" \"3 * 3 = 9\" xmap_mat(list(1:3, 1:6), prod) #>   1 2 3  4  5  6 #> 1 1 2 3  4  5  6 #> 2 2 4 6  8 10 12 #> 3 3 6 9 12 15 18 future::plan(\"multisession\") future_xmap_chr(list(1:3, 1:3), ~ paste(.x, \"*\", .y, \"=\", .x * .y)) #> [1] \"1 * 1 = 1\" \"2 * 1 = 2\" \"3 * 1 = 3\" \"1 * 2 = 2\" \"2 * 2 = 4\" \"3 * 2 = 6\" #> [7] \"1 * 3 = 3\" \"2 * 3 = 6\" \"3 * 3 = 9\" cross_fit(   mtcars,   formulas = list(hp = mpg ~ hp, drat = mpg ~ drat),   cols     = c(cyl, vs),   weights  = c(wt, NA) ) #> # A tibble: 40 × 21 #>    model weights   cyl    vs term      estimate  std.error  statistic    p.value #>    <chr> <chr>   <dbl> <dbl> <chr>        <dbl>      <dbl>      <dbl>      <dbl> #>  1 hp    NA          4     0 (Interce…  26      NaN        NaN        NaN        #>  2 hp    NA          4     0 hp         NA       NA         NA         NA        #>  3 hp    NA          4     1 (Interce…  36.0      5.52e+ 0   6.52e+ 0   1.85e- 4 #>  4 hp    NA          4     1 hp         -0.113    6.55e- 2  -1.73e+ 0   1.21e- 1 #>  5 hp    NA          6     0 (Interce…  23.2      1.98e-14   1.17e+15   5.43e-16 #>  6 hp    NA          6     0 hp         -0.0200   1.46e-16  -1.37e+14   4.66e-15 #>  7 hp    NA          6     1 (Interce…  24.2      1.41e+ 1   1.72e+ 0   2.28e- 1 #>  8 hp    NA          6     1 hp         -0.0440   1.22e- 1  -3.61e- 1   7.52e- 1 #>  9 hp    NA          8     0 (Interce…  18.1      2.99e+ 0   6.05e+ 0   5.74e- 5 #> 10 hp    NA          8     0 hp         -0.0142   1.39e- 2  -1.02e+ 0   3.26e- 1 #> # ℹ 30 more rows #> # ℹ 12 more variables: r.squared <dbl>, adj.r.squared <dbl>, sigma <dbl>, #> #   model.statistic <dbl>, model.p.value <dbl>, df <dbl>, logLik <dbl>, #> #   AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int> cross_list(number = 1:3, letter = letters[1:3]) #> $number #> [1] 1 2 3 1 2 3 1 2 3 #>  #> $letter #> [1] \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"c\" \"c\" \"c\" cross_tbl(number = 1:3, letter = letters[1:3]) #> # A tibble: 9 × 2 #>   number letter #>    <int> <chr>  #> 1      1 a      #> 2      2 a      #> 3      3 a      #> 4      1 b      #> 5      2 b      #> 6      3 b      #> 7      1 c      #> 8      2 c      #> 9      3 c cross_join(   tibble(     color = c(\"red\", \"yellow\", \"orange\"),     fruit = c(\"apple\", \"banana\", \"cantaloupe\")   ),   tibble(dessert = c(\"cupcake\", \"muffin\", \"streudel\"), makes = c(8, 6, 1)) ) #> # A tibble: 9 × 4 #>   color  fruit      dessert  makes #>   <chr>  <chr>      <chr>    <dbl> #> 1 red    apple      cupcake      8 #> 2 red    apple      muffin       6 #> 3 red    apple      streudel     1 #> 4 yellow banana     cupcake      8 #> 5 yellow banana     muffin       6 #> 6 yellow banana     streudel     1 #> 7 orange cantaloupe cupcake      8 #> 8 orange cantaloupe muffin       6 #> 9 orange cantaloupe streudel     1 map_vec(sample(5), ~ . ^ 2) #> [1] 25  9  4  1 16 map_vec(c(\"apple\", \"banana\", \"cantaloupe\"), paste0, \"s\") #> [1] \"apples\"      \"bananas\"     \"cantaloupes\""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/autonames.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically generate names for vectors — autonames","title":"Automatically generate names for vectors — autonames","text":"Automatically generate names vectors","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/autonames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically generate names for vectors — autonames","text":"","code":"autonames(x, ..., trimws = TRUE)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/autonames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically generate names for vectors — autonames","text":"x vector ... Additional arguments passed format() trimws Whether trim whitespace surrounding automatically formatted names. Defaults TRUE.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/autonames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically generate names for vectors — autonames","text":"Returns names named vector elements unnamed vector formatted characters.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/autonames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically generate names for vectors — autonames","text":"","code":"autonames(c(a = \"apple\", b = \"banana\", c = \"cantaloupe\")) #> [1] \"a\" \"b\" \"c\" autonames(c(\"apple\", \"banana\", \"cantaloupe\")) #> [1] \"apple\"      \"banana\"     \"cantaloupe\"  autonames(10^(1:4)) #> [1] \"10\"    \"100\"   \"1000\"  \"10000\" autonames(10^(1:4), big.mark = \",\") #> [1] \"10\"     \"100\"    \"1,000\"  \"10,000\" autonames(10^(1:4), scientific = TRUE) #> [1] \"1e+01\" \"1e+02\" \"1e+03\" \"1e+04\""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","title":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","text":"Applies modeling function every combination set formulas set data subsets.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","text":"","code":"cross_fit(   data,   formulas,   cols = NULL,   weights = NULL,   clusters = NULL,   families = NULL,   fn = lm,   fn_args = list(),   tidy = tidy_glance,   tidy_args = list(),   errors = c(\"stop\", \"warn\") )"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","text":"data data frame formulas list formulas apply subset data. named, names used model column output. Otherwise, formulas converted strings model column. cols Columns subset data. Can expression supported <tidy-select>. NULL, data subset columns. Defaults NULL. weights list columns passed weights fn. one elements NULL NA, model weighted. Defaults NULL. clusters list columns passed clusters supported fn. one elements NULL NA, model clustered. Defaults NULL. families list glm model families passed family supported fn. Defaults gaussian(\"identity\"), equivalent lm(). See family examples. fn modeling function. Either unquoted function name purrr-style lambda function two arguments. use multiple modeling functions, see cross_fit_glm(). Defaults lm. fn_args list additional arguments fn. tidy logical function use tidy model output data.frame columns. TRUE, uses default tidying function: tidy_glance(). FALSE, NA, NULL, untidied model output returned list column named fit. alternative function can specified unquoted function name purrr-style lambda function one argument (see usage broom::tidy(conf.int = TRUE) examples). Defaults tidy_glance. tidy_args list additional arguments tidy function errors \"stop\", default, function stop return error subset produces error. \"warn\", function produce warning subsets produce error return results subsets .","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","text":"tibble column model formula, columns subsets, columns model family type (applicable), columns weights clusters (applicable), columns tidy model output list column models (tidy = FALSE)","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross map a model across multiple formulas, subsets, and weights — cross_fit","text":"","code":"cross_fit(mtcars, mpg ~ wt, cyl) #> # A tibble: 6 × 19 #>   model   cyl term  estimate std.error statistic p.value r.squared adj.r.squared #>   <chr> <dbl> <chr>    <dbl>     <dbl>     <dbl>   <dbl>     <dbl>         <dbl> #> 1 mpg …     4 (Int…    39.6      4.35       9.10 7.77e-6     0.509         0.454 #> 2 mpg …     4 wt       -5.65     1.85      -3.05 1.37e-2     0.509         0.454 #> 3 mpg …     6 (Int…    28.4      4.18       6.79 1.05e-3     0.465         0.357 #> 4 mpg …     6 wt       -2.78     1.33      -2.08 9.18e-2     0.465         0.357 #> 5 mpg …     8 (Int…    23.9      3.01       7.94 4.05e-6     0.423         0.375 #> 6 mpg …     8 wt       -2.19     0.739     -2.97 1.18e-2     0.423         0.375 #> # ℹ 10 more variables: sigma <dbl>, model.statistic <dbl>, model.p.value <dbl>, #> #   df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, #> #   df.residual <int>, nobs <int> cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl) #> # A tibble: 12 × 19 #>    model      cyl term        estimate std.error statistic    p.value r.squared #>    <chr>    <dbl> <chr>          <dbl>     <dbl>     <dbl>      <dbl>     <dbl> #>  1 mpg ~ wt     4 (Intercept) 39.6        4.35       9.10  0.00000777    0.509  #>  2 mpg ~ wt     4 wt          -5.65       1.85      -3.05  0.0137        0.509  #>  3 mpg ~ wt     6 (Intercept) 28.4        4.18       6.79  0.00105       0.465  #>  4 mpg ~ wt     6 wt          -2.78       1.33      -2.08  0.0918        0.465  #>  5 mpg ~ wt     8 (Intercept) 23.9        3.01       7.94  0.00000405    0.423  #>  6 mpg ~ wt     8 wt          -2.19       0.739     -2.97  0.0118        0.423  #>  7 mpg ~ hp     4 (Intercept) 36.0        5.20       6.92  0.0000693     0.274  #>  8 mpg ~ hp     4 hp          -0.113      0.0612    -1.84  0.0984        0.274  #>  9 mpg ~ hp     6 (Intercept) 20.7        3.30       6.26  0.00153       0.0161 #> 10 mpg ~ hp     6 hp          -0.00761    0.0266    -0.286 0.786         0.0161 #> 11 mpg ~ hp     8 (Intercept) 18.1        2.99       6.05  0.0000574     0.0804 #> 12 mpg ~ hp     8 hp          -0.0142     0.0139    -1.02  0.326         0.0804 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int> cross_fit(mtcars, list(wt = mpg ~ wt, hp = mpg ~ hp), cyl) #> # A tibble: 12 × 19 #>    model   cyl term        estimate std.error statistic    p.value r.squared #>    <chr> <dbl> <chr>          <dbl>     <dbl>     <dbl>      <dbl>     <dbl> #>  1 wt        4 (Intercept) 39.6        4.35       9.10  0.00000777    0.509  #>  2 wt        4 wt          -5.65       1.85      -3.05  0.0137        0.509  #>  3 wt        6 (Intercept) 28.4        4.18       6.79  0.00105       0.465  #>  4 wt        6 wt          -2.78       1.33      -2.08  0.0918        0.465  #>  5 wt        8 (Intercept) 23.9        3.01       7.94  0.00000405    0.423  #>  6 wt        8 wt          -2.19       0.739     -2.97  0.0118        0.423  #>  7 hp        4 (Intercept) 36.0        5.20       6.92  0.0000693     0.274  #>  8 hp        4 hp          -0.113      0.0612    -1.84  0.0984        0.274  #>  9 hp        6 (Intercept) 20.7        3.30       6.26  0.00153       0.0161 #> 10 hp        6 hp          -0.00761    0.0266    -0.286 0.786         0.0161 #> 11 hp        8 (Intercept) 18.1        2.99       6.05  0.0000574     0.0804 #> 12 hp        8 hp          -0.0142     0.0139    -1.02  0.326         0.0804 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int>  cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), c(cyl, vs)) #> Warning: There were 4 warnings in `dplyr::reframe()`. #> The first warning was: #> ℹ In argument: `tidy(...)`. #> ℹ In row 8. #> Caused by warning in `summary.lm()`: #> ! essentially perfect fit: summary may be unreliable #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 3 remaining warnings. #> # A tibble: 20 × 20 #>    model     cyl    vs term  estimate  std.error  statistic    p.value r.squared #>    <chr>   <dbl> <dbl> <chr>    <dbl>      <dbl>      <dbl>      <dbl>     <dbl> #>  1 mpg ~ …     4     0 (Int…  26      NaN        NaN        NaN           0      #>  2 mpg ~ …     4     0 wt     NA       NA         NA         NA           0      #>  3 mpg ~ …     4     1 (Int…  39.9      4.61e+ 0   8.66e+ 0   2.47e- 5    0.520  #>  4 mpg ~ …     4     1 wt     -5.72     1.95e+ 0  -2.94e+ 0   1.87e- 2    0.520  #>  5 mpg ~ …     6     0 (Int…  22.2      1.61e+ 1   1.38e+ 0   3.99e- 1    0.0103 #>  6 mpg ~ …     6     0 wt     -0.594    5.83e+ 0  -1.02e- 1   9.35e- 1    0.0103 #>  7 mpg ~ …     6     1 (Int…  63.6      1.19e+ 1   5.36e+ 0   3.30e- 2    0.876  #>  8 mpg ~ …     6     1 wt    -13.1      3.50e+ 0  -3.75e+ 0   6.42e- 2    0.876  #>  9 mpg ~ …     8     0 (Int…  23.9      3.01e+ 0   7.94e+ 0   4.05e- 6    0.423  #> 10 mpg ~ …     8     0 wt     -2.19     7.39e- 1  -2.97e+ 0   1.18e- 2    0.423  #> 11 mpg ~ …     4     0 (Int…  26      NaN        NaN        NaN           0      #> 12 mpg ~ …     4     0 hp     NA       NA         NA         NA           0      #> 13 mpg ~ …     4     1 (Int…  36.0      5.52e+ 0   6.52e+ 0   1.85e- 4    0.273  #> 14 mpg ~ …     4     1 hp     -0.113    6.55e- 2  -1.73e+ 0   1.21e- 1    0.273  #> 15 mpg ~ …     6     0 (Int…  23.2      1.02e-14   2.28e+15   2.79e-16    1      #> 16 mpg ~ …     6     0 hp     -0.0200   7.53e-17  -2.66e+14   2.40e-15    1      #> 17 mpg ~ …     6     1 (Int…  24.2      1.41e+ 1   1.72e+ 0   2.28e- 1    0.0613 #> 18 mpg ~ …     6     1 hp     -0.0440   1.22e- 1  -3.61e- 1   7.52e- 1    0.0613 #> 19 mpg ~ …     8     0 (Int…  18.1      2.99e+ 0   6.05e+ 0   5.74e- 5    0.0804 #> 20 mpg ~ …     8     0 hp     -0.0142   1.39e- 2  -1.02e+ 0   3.26e- 1    0.0804 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int> cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), dplyr::starts_with(\"c\")) #> # A tibble: 36 × 20 #>    model      cyl  carb term    estimate std.error statistic   p.value r.squared #>    <chr>    <dbl> <dbl> <chr>      <dbl>     <dbl>     <dbl>     <dbl>     <dbl> #>  1 mpg ~ wt     4     1 (Inter…    62.0      17.2       3.60   3.67e-2     0.574 #>  2 mpg ~ wt     4     1 wt        -16.0       7.95     -2.01   1.38e-1     0.574 #>  3 mpg ~ wt     4     2 (Inter…    36.8       2.83     13.0    2.01e-4     0.802 #>  4 mpg ~ wt     4     2 wt         -4.56      1.13     -4.02   1.59e-2     0.802 #>  5 mpg ~ wt     6     1 (Inter…    64.7     NaN       NaN    NaN           1     #>  6 mpg ~ wt     6     1 wt        -13.5     NaN       NaN    NaN           1     #>  7 mpg ~ wt     6     4 (Inter…    30.2       3.61      8.37   1.40e-2     0.810 #>  8 mpg ~ wt     6     4 wt         -3.38      1.16     -2.92   1.00e-1     0.810 #>  9 mpg ~ wt     6     6 (Inter…    19.7     NaN       NaN    NaN           0     #> 10 mpg ~ wt     6     6 wt         NA        NA        NA     NA           0     #> # ℹ 26 more rows #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int>  cross_fit(mtcars, list(hp = mpg ~ hp), cyl, weights = wt) #> # A tibble: 6 × 20 #>   model weights   cyl term        estimate std.error statistic p.value r.squared #>   <chr> <chr>   <dbl> <chr>          <dbl>     <dbl>     <dbl>   <dbl>     <dbl> #> 1 hp    wt          4 (Intercept) 36.2        5.14       7.03  6.10e-5    0.316  #> 2 hp    wt          4 hp          -0.123      0.0601    -2.04  7.17e-2    0.316  #> 3 hp    wt          6 (Intercept) 20.4        3.49       5.85  2.07e-3    0.0107 #> 4 hp    wt          6 hp          -0.00657    0.0283    -0.232 8.26e-1    0.0107 #> 5 hp    wt          8 (Intercept) 18.0        3.36       5.36  1.72e-4    0.0724 #> 6 hp    wt          8 hp          -0.0151     0.0156    -0.968 3.52e-1    0.0724 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int> cross_fit(mtcars, list(hp = mpg ~ hp), cyl, weights = c(wt, NA)) #> # A tibble: 12 × 20 #>    model weights   cyl term       estimate std.error statistic p.value r.squared #>    <chr> <chr>   <dbl> <chr>         <dbl>     <dbl>     <dbl>   <dbl>     <dbl> #>  1 hp    NA          4 (Intercep… 36.0        5.20       6.92  6.93e-5    0.274  #>  2 hp    NA          4 hp         -0.113      0.0612    -1.84  9.84e-2    0.274  #>  3 hp    NA          6 (Intercep… 20.7        3.30       6.26  1.53e-3    0.0161 #>  4 hp    NA          6 hp         -0.00761    0.0266    -0.286 7.86e-1    0.0161 #>  5 hp    NA          8 (Intercep… 18.1        2.99       6.05  5.74e-5    0.0804 #>  6 hp    NA          8 hp         -0.0142     0.0139    -1.02  3.26e-1    0.0804 #>  7 hp    wt          4 (Intercep… 36.2        5.14       7.03  6.10e-5    0.316  #>  8 hp    wt          4 hp         -0.123      0.0601    -2.04  7.17e-2    0.316  #>  9 hp    wt          6 (Intercep… 20.4        3.49       5.85  2.07e-3    0.0107 #> 10 hp    wt          6 hp         -0.00657    0.0283    -0.232 8.26e-1    0.0107 #> 11 hp    wt          8 (Intercep… 18.0        3.36       5.36  1.72e-4    0.0724 #> 12 hp    wt          8 hp         -0.0151     0.0156    -0.968 3.52e-1    0.0724 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int>  cross_fit(   mtcars, list(vs ~ cyl, vs ~ hp), am,   fn = glm, fn_args = list(family = binomial(link = logit)) ) #> Warning: There were 4 warnings in `dplyr::reframe()`. #> The first warning was: #> ℹ In argument: `tidy(...)`. #> ℹ In row 1. #> Caused by warning: #> ! glm.fit: fitted probabilities numerically 0 or 1 occurred #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 3 remaining warnings. #> # A tibble: 8 × 15 #>   model      am term  estimate std.error statistic p.value null.deviance df.null #>   <chr>   <dbl> <chr>    <dbl>     <dbl>     <dbl>   <dbl>         <dbl>   <int> #> 1 vs ~ c…     0 (Int… 172.       2.52e+5  0.000682   0.999          25.0      18 #> 2 vs ~ c…     0 cyl   -24.6      3.57e+4 -0.000689   0.999          25.0      18 #> 3 vs ~ c…     1 (Int…  44.3      1.04e+4  0.00424    0.997          17.9      12 #> 4 vs ~ c…     1 cyl   -10.6      2.61e+3 -0.00406    0.997          17.9      12 #> 5 vs ~ hp     0 (Int… 231.       2.76e+5  0.000835   0.999          25.0      18 #> 6 vs ~ hp     0 hp     -1.69     2.00e+3 -0.000844   0.999          25.0      18 #> 7 vs ~ hp     1 (Int…   7.07     4.76e+0  1.49       0.137          17.9      12 #> 8 vs ~ hp     1 hp     -0.0663   4.67e-2 -1.42       0.156          17.9      12 #> # ℹ 6 more variables: logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, #> #   df.residual <int>, nobs <int> cross_fit(   mtcars, list(vs ~ cyl, vs ~ hp), am,   fn = ~ glm(.x, .y, family = binomial(link = logit)) ) #> Warning: There were 4 warnings in `dplyr::reframe()`. #> The first warning was: #> ℹ In argument: `tidy(...)`. #> ℹ In row 1. #> Caused by warning: #> ! glm.fit: fitted probabilities numerically 0 or 1 occurred #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 3 remaining warnings. #> # A tibble: 8 × 15 #>   model      am term  estimate std.error statistic p.value null.deviance df.null #>   <chr>   <dbl> <chr>    <dbl>     <dbl>     <dbl>   <dbl>         <dbl>   <int> #> 1 vs ~ c…     0 (Int… 172.       2.52e+5  0.000682   0.999          25.0      18 #> 2 vs ~ c…     0 cyl   -24.6      3.57e+4 -0.000689   0.999          25.0      18 #> 3 vs ~ c…     1 (Int…  44.3      1.04e+4  0.00424    0.997          17.9      12 #> 4 vs ~ c…     1 cyl   -10.6      2.61e+3 -0.00406    0.997          17.9      12 #> 5 vs ~ hp     0 (Int… 231.       2.76e+5  0.000835   0.999          25.0      18 #> 6 vs ~ hp     0 hp     -1.69     2.00e+3 -0.000844   0.999          25.0      18 #> 7 vs ~ hp     1 (Int…   7.07     4.76e+0  1.49       0.137          17.9      12 #> 8 vs ~ hp     1 hp     -0.0663   4.67e-2 -1.42       0.156          17.9      12 #> # ℹ 6 more variables: logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, #> #   df.residual <int>, nobs <int>  cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy = FALSE) #> # A tibble: 6 × 3 #>   model      cyl fit    #>   <chr>    <dbl> <list> #> 1 mpg ~ wt     4 <lm>   #> 2 mpg ~ wt     6 <lm>   #> 3 mpg ~ wt     8 <lm>   #> 4 mpg ~ hp     4 <lm>   #> 5 mpg ~ hp     6 <lm>   #> 6 mpg ~ hp     8 <lm>   cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy_args = c(conf.int = TRUE)) #> # A tibble: 12 × 21 #>    model      cyl term   estimate std.error statistic p.value conf.low conf.high #>    <chr>    <dbl> <chr>     <dbl>     <dbl>     <dbl>   <dbl>    <dbl>     <dbl> #>  1 mpg ~ wt     4 (Inte… 39.6        4.35       9.10  7.77e-6  29.7      49.4    #>  2 mpg ~ wt     4 wt     -5.65       1.85      -3.05  1.37e-2  -9.83     -1.46   #>  3 mpg ~ wt     6 (Inte… 28.4        4.18       6.79  1.05e-3  17.7      39.2    #>  4 mpg ~ wt     6 wt     -2.78       1.33      -2.08  9.18e-2  -6.21      0.651  #>  5 mpg ~ wt     8 (Inte… 23.9        3.01       7.94  4.05e-6  17.3      30.4    #>  6 mpg ~ wt     8 wt     -2.19       0.739     -2.97  1.18e-2  -3.80     -0.582  #>  7 mpg ~ hp     4 (Inte… 36.0        5.20       6.92  6.93e-5  24.2      47.7    #>  8 mpg ~ hp     4 hp     -0.113      0.0612    -1.84  9.84e-2  -0.251     0.0256 #>  9 mpg ~ hp     6 (Inte… 20.7        3.30       6.26  1.53e-3  12.2      29.2    #> 10 mpg ~ hp     6 hp     -0.00761    0.0266    -0.286 7.86e-1  -0.0759    0.0607 #> 11 mpg ~ hp     8 (Inte… 18.1        2.99       6.05  5.74e-5  11.6      24.6    #> 12 mpg ~ hp     8 hp     -0.0142     0.0139    -1.02  3.26e-1  -0.0445    0.0160 #> # ℹ 12 more variables: r.squared <dbl>, adj.r.squared <dbl>, sigma <dbl>, #> #   model.statistic <dbl>, model.p.value <dbl>, df <dbl>, logLik <dbl>, #> #   AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>  cross_fit(mtcars, list(mpg ~ wt, mpg ~ hp), cyl, tidy = broom::tidy) #> # A tibble: 12 × 7 #>    model      cyl term        estimate std.error statistic    p.value #>    <chr>    <dbl> <chr>          <dbl>     <dbl>     <dbl>      <dbl> #>  1 mpg ~ wt     4 (Intercept) 39.6        4.35       9.10  0.00000777 #>  2 mpg ~ wt     4 wt          -5.65       1.85      -3.05  0.0137     #>  3 mpg ~ wt     6 (Intercept) 28.4        4.18       6.79  0.00105    #>  4 mpg ~ wt     6 wt          -2.78       1.33      -2.08  0.0918     #>  5 mpg ~ wt     8 (Intercept) 23.9        3.01       7.94  0.00000405 #>  6 mpg ~ wt     8 wt          -2.19       0.739     -2.97  0.0118     #>  7 mpg ~ hp     4 (Intercept) 36.0        5.20       6.92  0.0000693  #>  8 mpg ~ hp     4 hp          -0.113      0.0612    -1.84  0.0984     #>  9 mpg ~ hp     6 (Intercept) 20.7        3.30       6.26  0.00153    #> 10 mpg ~ hp     6 hp          -0.00761    0.0266    -0.286 0.786      #> 11 mpg ~ hp     8 (Intercept) 18.1        2.99       6.05  0.0000574  #> 12 mpg ~ hp     8 hp          -0.0142     0.0139    -1.02  0.326      cross_fit(   mtcars, list(mpg ~ wt, mpg ~ hp), cyl,   tidy = ~ broom::tidy(., conf.int = TRUE) ) #> # A tibble: 12 × 9 #>    model      cyl term   estimate std.error statistic p.value conf.low conf.high #>    <chr>    <dbl> <chr>     <dbl>     <dbl>     <dbl>   <dbl>    <dbl>     <dbl> #>  1 mpg ~ wt     4 (Inte… 39.6        4.35       9.10  7.77e-6  29.7      49.4    #>  2 mpg ~ wt     4 wt     -5.65       1.85      -3.05  1.37e-2  -9.83     -1.46   #>  3 mpg ~ wt     6 (Inte… 28.4        4.18       6.79  1.05e-3  17.7      39.2    #>  4 mpg ~ wt     6 wt     -2.78       1.33      -2.08  9.18e-2  -6.21      0.651  #>  5 mpg ~ wt     8 (Inte… 23.9        3.01       7.94  4.05e-6  17.3      30.4    #>  6 mpg ~ wt     8 wt     -2.19       0.739     -2.97  1.18e-2  -3.80     -0.582  #>  7 mpg ~ hp     4 (Inte… 36.0        5.20       6.92  6.93e-5  24.2      47.7    #>  8 mpg ~ hp     4 hp     -0.113      0.0612    -1.84  9.84e-2  -0.251     0.0256 #>  9 mpg ~ hp     6 (Inte… 20.7        3.30       6.26  1.53e-3  12.2      29.2    #> 10 mpg ~ hp     6 hp     -0.00761    0.0266    -0.286 7.86e-1  -0.0759    0.0607 #> 11 mpg ~ hp     8 (Inte… 18.1        2.99       6.05  5.74e-5  11.6      24.6    #> 12 mpg ~ hp     8 hp     -0.0142     0.0139    -1.02  3.26e-1  -0.0445    0.0160"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross fit generalized linear models — cross_fit_glm","title":"Cross fit generalized linear models — cross_fit_glm","text":"Cross fit generalized linear models","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross fit generalized linear models — cross_fit_glm","text":"","code":"cross_fit_glm(   data,   formulas,   cols = NULL,   weights = NULL,   families = gaussian(link = identity),   fn_args = list(),   tidy = tidy_glance,   tidy_args = list(),   errors = c(\"stop\", \"warn\") )"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross fit generalized linear models — cross_fit_glm","text":"data data frame formulas list formulas apply subset data. named, names used model column output. Otherwise, formulas converted strings model column. cols Columns subset data. Can expression supported <tidy-select>. NULL, data subset columns. Defaults NULL. weights list columns passed weights fn. one elements NULL NA, model weighted. Defaults NULL. families list glm model families. Defaults gaussian(\"identity\"), equivalent lm(). See family examples. fn_args list additional arguments glm(). tidy logical function use tidy model output data.frame columns. TRUE, uses default tidying function: tidy_glance(). FALSE, NA, NULL, untidied model output returned list column named fit. alternative function can specified unquoted function name purrr-style lambda function one argument (see usage broom::tidy(conf.int = TRUE) examples). Defaults tidy_glance. tidy_args list additional arguments tidy function errors \"stop\", default, function stop return error subset produces error. \"warn\", function produce warning subsets produce error return results subsets .","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross fit generalized linear models — cross_fit_glm","text":"tibble column model formula, columns subsets, columns model family type, columns weights (applicable), columns tidy model output list column models (tidy = FALSE)","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross fit generalized linear models — cross_fit_glm","text":"","code":"cross_fit_glm(   data     = mtcars,   formulas = list(am ~ gear, am ~ cyl),   cols     = vs,   families = list(gaussian(\"identity\"), binomial(\"logit\")) ) #> Warning: There were 2 warnings in `dplyr::reframe()`. #> The first warning was: #> ℹ In argument: `tidy(...)`. #> ℹ In row 3. #> Caused by warning: #> ! glm.fit: fitted probabilities numerically 0 or 1 occurred #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning. #> # A tibble: 16 × 17 #>    model     family   link        vs term  estimate std.error statistic  p.value #>    <chr>     <chr>    <chr>    <dbl> <chr>    <dbl>     <dbl>     <dbl>    <dbl> #>  1 am ~ gear gaussian identity     0 (Int…   -1.57    1.69e-1 -9.28     7.73 e-8 #>  2 am ~ gear gaussian identity     0 gear     0.536   4.64e-2 11.5      3.59 e-9 #>  3 am ~ gear gaussian identity     1 (Int…   -1.58    9.07e-1 -1.74     1.08 e-1 #>  4 am ~ gear gaussian identity     1 gear     0.538   2.33e-1  2.31     3.95 e-2 #>  5 am ~ gear binomial logit        0 (Int… -177.      4.09e+5 -0.000434 1.000e+0 #>  6 am ~ gear binomial logit        0 gear    50.4     1.16e+5  0.000436 1.000e+0 #>  7 am ~ gear binomial logit        1 (Int…  -74.8     1.28e+4 -0.00582  9.95 e-1 #>  8 am ~ gear binomial logit        1 gear    18.8     3.21e+3  0.00585  9.95 e-1 #>  9 am ~ cyl  gaussian identity     0 (Int…    2.54    5.65e-1  4.51     3.58 e-4 #> 10 am ~ cyl  gaussian identity     0 cyl     -0.297   7.50e-2 -3.96     1.12 e-3 #> 11 am ~ cyl  gaussian identity     1 (Int…    2.10    5.77e-1  3.64     3.38 e-3 #> 12 am ~ cyl  gaussian identity     1 cyl     -0.35    1.24e-1 -2.83     1.52 e-2 #> 13 am ~ cyl  binomial logit        0 (Int…   79.7     1.52e+4  0.00526  9.96 e-1 #> 14 am ~ cyl  binomial logit        0 cyl    -10.2     1.89e+3 -0.00538  9.96 e-1 #> 15 am ~ cyl  binomial logit        1 (Int…   39.7     6.52e+3  0.00608  9.95 e-1 #> 16 am ~ cyl  binomial logit        1 cyl     -9.71    1.63e+3 -0.00595  9.95 e-1 #> # ℹ 8 more variables: null.deviance <dbl>, df.null <int>, logLik <dbl>, #> #   AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_robust.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross fit robust linear models — cross_fit_robust","title":"Cross fit robust linear models — cross_fit_robust","text":"Cross fit robust linear models","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_robust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross fit robust linear models — cross_fit_robust","text":"","code":"cross_fit_robust(   data,   formulas,   cols = NULL,   weights = NULL,   clusters = NULL,   fn_args = list(),   tidy = tidy_glance,   tidy_args = list(),   errors = c(\"stop\", \"warn\") )"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_robust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross fit robust linear models — cross_fit_robust","text":"data data frame formulas list formulas apply subset data. named, names used model column output. Otherwise, formulas converted strings model column. cols Columns subset data. Can expression supported <tidy-select>. NULL, data subset columns. Defaults NULL. weights list columns passed weights fn. one elements NULL NA, model weighted. Defaults NULL. clusters list columns passed clusters. one elements NULL NA, model clustered. Defaults NULL. fn_args list additional arguments estimatr::lm_robust(). tidy logical function use tidy model output data.frame columns. TRUE, uses default tidying function: tidy_glance(). FALSE, NA, NULL, untidied model output returned list column named fit. alternative function can specified unquoted function name purrr-style lambda function one argument (see usage broom::tidy(conf.int = TRUE) examples). Defaults tidy_glance. tidy_args list additional arguments tidy function errors \"stop\", default, function stop return error subset produces error. \"warn\", function produce warning subsets produce error return results subsets .","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_robust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross fit robust linear models — cross_fit_robust","text":"tibble column model formula, columns subsets, columns weights clusters (applicable), columns tidy model output list column models (tidy = FALSE)","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_fit_robust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross fit robust linear models — cross_fit_robust","text":"","code":"cross_fit_robust(mtcars, mpg ~ wt, cyl, clusters = list(NULL, am)) #> # A tibble: 12 × 19 #>    model    clusters   cyl term    estimate std.error statistic p.value conf.low #>    <chr>    <chr>    <dbl> <chr>      <dbl>     <dbl>     <dbl>   <dbl>    <dbl> #>  1 mpg ~ wt NULL         4 (Inter…    39.6      3.20      12.4  5.95e-7    32.3  #>  2 mpg ~ wt NULL         4 wt         -5.65     1.37      -4.12 2.59e-3    -8.75 #>  3 mpg ~ wt NULL         6 (Inter…    28.4      2.82      10.1  1.66e-4    21.2  #>  4 mpg ~ wt NULL         6 wt         -2.78     0.934     -2.98 3.09e-2    -5.18 #>  5 mpg ~ wt NULL         8 (Inter…    23.9      3.19       7.48 7.45e-6    16.9  #>  6 mpg ~ wt NULL         8 wt         -2.19     0.825     -2.66 2.09e-2    -3.99 #>  7 mpg ~ wt am           4 (Inter…    39.6      6.59       6.00 6.11e-2    -6.45 #>  8 mpg ~ wt am           4 wt         -5.65     2.55      -2.21 2.19e-1   -24.3  #>  9 mpg ~ wt am           6 (Inter…    28.4      6.54       4.35 6.75e-2    -5.94 #> 10 mpg ~ wt am           6 wt         -2.78     1.94      -1.43 3.01e-1   -12.1  #> 11 mpg ~ wt am           8 (Inter…    23.9      1.94      12.3  4.13e-2     3.83 #> 12 mpg ~ wt am           8 wt         -2.19     0.391     -5.60 9.61e-2    -6.19 #> # ℹ 10 more variables: conf.high <dbl>, df <dbl>, outcome <chr>, #> #   r.squared <dbl>, adj.r.squared <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df.residual <dbl>, nobs <int>, se_type <chr>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Crossing join — cross_join","title":"Crossing join — cross_join","text":"Adds columns set data frames, creating combinations rows","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crossing join — cross_join","text":"","code":"cross_join(..., copy = FALSE)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crossing join — cross_join","text":"... Data frames list data frames – including data frame extensions (e.g. tibbles) lazy data frames (e.g. dbplyr dtplyr). NULL inputs silently ignored. copy inputs data source, copy TRUE, copied src first input. allows join tables across srcs, potentially expensive operation must opt .","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crossing join — cross_join","text":"object type first input. order rows columns first input preserved much possible. output following properties: Rows input duplicated. Output columns include columns input. columns name, suffixes added disambiguate. Groups taken first input.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crossing join — cross_join","text":"","code":"fruits <- dplyr::tibble(   fruit = c(\"apple\", \"banana\", \"cantaloupe\"),   color = c(\"red\", \"yellow\", \"orange\") )  desserts <- dplyr::tibble(   dessert = c(\"cupcake\", \"muffin\", \"streudel\"),   makes   = c(8, 6, 1) )  cross_join(fruits, desserts) #> # A tibble: 9 × 4 #>   fruit      color  dessert  makes #>   <chr>      <chr>  <chr>    <dbl> #> 1 apple      red    cupcake      8 #> 2 apple      red    muffin       6 #> 3 apple      red    streudel     1 #> 4 banana     yellow cupcake      8 #> 5 banana     yellow muffin       6 #> 6 banana     yellow streudel     1 #> 7 cantaloupe orange cupcake      8 #> 8 cantaloupe orange muffin       6 #> 9 cantaloupe orange streudel     1 cross_join(list(fruits, desserts)) #> # A tibble: 9 × 4 #>   fruit      color  dessert  makes #>   <chr>      <chr>  <chr>    <dbl> #> 1 apple      red    cupcake      8 #> 2 apple      red    muffin       6 #> 3 apple      red    streudel     1 #> 4 banana     yellow cupcake      8 #> 5 banana     yellow muffin       6 #> 6 banana     yellow streudel     1 #> 7 cantaloupe orange cupcake      8 #> 8 cantaloupe orange muffin       6 #> 9 cantaloupe orange streudel     1 cross_join(rep(list(fruits), 3)) #> # A tibble: 27 × 6 #>    fruit.1 color.1 fruit.2    color.2 fruit.3    color.3 #>    <chr>   <chr>   <chr>      <chr>   <chr>      <chr>   #>  1 apple   red     apple      red     apple      red     #>  2 apple   red     apple      red     banana     yellow  #>  3 apple   red     apple      red     cantaloupe orange  #>  4 apple   red     banana     yellow  apple      red     #>  5 apple   red     banana     yellow  banana     yellow  #>  6 apple   red     banana     yellow  cantaloupe orange  #>  7 apple   red     cantaloupe orange  apple      red     #>  8 apple   red     cantaloupe orange  banana     yellow  #>  9 apple   red     cantaloupe orange  cantaloupe orange  #> 10 banana  yellow  apple      red     apple      red     #> # ℹ 17 more rows"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_list.html","id":null,"dir":"Reference","previous_headings":"","what":"List all combinations of values — cross_list","title":"List all combinations of values — cross_list","text":"List combinations values","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all combinations of values — cross_list","text":"","code":"cross_list(...)  cross_tbl(...)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List all combinations of values — cross_list","text":"... Inputs list inputs. NULL inputs silently ignored.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all combinations of values — cross_list","text":"list cross_list() tibble cross_tbl(). Names match names inputs. Unnamed inputs left unnamed cross_list() automatically named cross_tbl().","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/cross_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List all combinations of values — cross_list","text":"","code":"fruits   <- c(\"apple\", \"banana\", \"cantaloupe\") desserts <- c(\"cupcake\", \"muffin\", \"streudel\")  cross_list(list(fruits, desserts)) #> [[1]] #> [1] \"apple\"      \"banana\"     \"cantaloupe\" \"apple\"      \"banana\"     #> [6] \"cantaloupe\" \"apple\"      \"banana\"     \"cantaloupe\" #>  #> [[2]] #> [1] \"cupcake\"  \"cupcake\"  \"cupcake\"  \"muffin\"   \"muffin\"   \"muffin\"   \"streudel\" #> [8] \"streudel\" \"streudel\" #>  cross_list(fruits, desserts) #> [[1]] #> [1] \"apple\"      \"banana\"     \"cantaloupe\" \"apple\"      \"banana\"     #> [6] \"cantaloupe\" \"apple\"      \"banana\"     \"cantaloupe\" #>  #> [[2]] #> [1] \"cupcake\"  \"cupcake\"  \"cupcake\"  \"muffin\"   \"muffin\"   \"muffin\"   \"streudel\" #> [8] \"streudel\" \"streudel\" #>  cross_tbl(fruits, desserts) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> # A tibble: 9 × 2 #>   ...1       ...2     #>   <chr>      <chr>    #> 1 apple      cupcake  #> 2 banana     cupcake  #> 3 cantaloupe cupcake  #> 4 apple      muffin   #> 5 banana     muffin   #> 6 cantaloupe muffin   #> 7 apple      streudel #> 8 banana     streudel #> 9 cantaloupe streudel  cross_list(list(fruit = fruits, dessert = desserts)) #> $fruit #> [1] \"apple\"      \"banana\"     \"cantaloupe\" \"apple\"      \"banana\"     #> [6] \"cantaloupe\" \"apple\"      \"banana\"     \"cantaloupe\" #>  #> $dessert #> [1] \"cupcake\"  \"cupcake\"  \"cupcake\"  \"muffin\"   \"muffin\"   \"muffin\"   \"streudel\" #> [8] \"streudel\" \"streudel\" #>  cross_list(fruit = fruits, dessert = desserts) #> $fruit #> [1] \"apple\"      \"banana\"     \"cantaloupe\" \"apple\"      \"banana\"     #> [6] \"cantaloupe\" \"apple\"      \"banana\"     \"cantaloupe\" #>  #> $dessert #> [1] \"cupcake\"  \"cupcake\"  \"cupcake\"  \"muffin\"   \"muffin\"   \"muffin\"   \"streudel\" #> [8] \"streudel\" \"streudel\" #>  cross_tbl(fruit = fruits, dessert = desserts) #> # A tibble: 9 × 2 #>   fruit      dessert  #>   <chr>      <chr>    #> 1 apple      cupcake  #> 2 banana     cupcake  #> 3 cantaloupe cupcake  #> 4 apple      muffin   #> 5 banana     muffin   #> 6 cantaloupe muffin   #> 7 apple      streudel #> 8 banana     streudel #> 9 cantaloupe streudel"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/crossmap-package.html","id":null,"dir":"Reference","previous_headings":"","what":"crossmap: Apply Functions to All Combinations of List Elements — crossmap-package","title":"crossmap: Apply Functions to All Combinations of List Elements — crossmap-package","text":"Provides extension 'purrr' family mapping functions apply function combination elements list inputs. Also includes functions automatically detecting output type mapping functions, finding every combination elements lists rows data frames, applying multiple models multiple subsets dataset.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/crossmap-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"crossmap: Apply Functions to All Combinations of List Elements — crossmap-package","text":"Maintainer: Alexander Rossell Hayes alexander@rossellhayes.com (ORCID) [copyright holder]","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_map_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized mapping functions that automatically determine type — future_map_vec","title":"Parallelized mapping functions that automatically determine type — future_map_vec","text":"functions work exactly map_vec(), map2_vec(), pmap_vec(), imap_vec() xmap_vec(), allow map parallel.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_map_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized mapping functions that automatically determine type — future_map_vec","text":"","code":"future_map_vec(   .x,   .f,   ...,   .class = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )  future_map2_vec(   .x,   .y,   .f,   ...,   .class = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )  future_pmap_vec(   .l,   .f,   ...,   .class = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )  future_imap_vec(   .x,   .f,   ...,   .class = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_vec(   .l,   .f,   ...,   .class = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_map_vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized mapping functions that automatically determine type — future_map_vec","text":".x list atomic vector. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .class .class specified, .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .options future specific options use workers. must result call furrr_options(). .y vector length .x. Vectors length 1 recycled. .l list vectors, data frame. length .l determines number arguments .f called . List names used present.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_map_vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelized mapping functions that automatically determine type — future_map_vec","text":"Equivalent map_vec(), map2_vec(), pmap_vec(), imap_vec() xmap_vec()","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_map_vec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelized mapping functions that automatically determine type — future_map_vec","text":"","code":"fruits   <- c(\"apple\", \"banana\", \"carrot\", \"durian\", \"eggplant\") desserts <- c(\"bread\", \"cake\", \"cupcake\", \"streudel\", \"muffin\") x        <- sample(5) y        <- sample(5) z        <- sample(5) names(z) <- fruits  future_map_vec(x, ~ . ^ 2) #> ! `future_map_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] 16  1  4  9 25 future_map_vec(fruits, paste0, \"s\") #> ! `future_map_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] \"apples\"    \"bananas\"   \"carrots\"   \"durians\"   \"eggplants\"  future_map2_vec(x, y, ~ .x + .y) #> ! `future_map2_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] 8 6 4 4 8 future_map2_vec(fruits, desserts, paste) #> ! `future_map2_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] \"apple bread\"     \"banana cake\"     \"carrot cupcake\"  \"durian streudel\" #> [5] \"eggplant muffin\"  future_pmap_vec(list(x, y, z), sum) #> ! `future_pmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] 11 11  5  6 12 future_pmap_vec(list(x, fruits, desserts), paste) #> ! `future_pmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] \"4 apple bread\"     \"1 banana cake\"     \"2 carrot cupcake\"  #> [4] \"3 durian streudel\" \"5 eggplant muffin\"  future_imap_vec(x, ~ .x + .y) #> ! `future_imap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1]  5  3  5  7 10 future_imap_vec(x, ~ paste0(.y, \": \", .x)) #> ! `future_imap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] \"1: 4\" \"2: 1\" \"3: 2\" \"4: 3\" \"5: 5\" future_imap_vec(z, paste) #> ! `future_imap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>        apple       banana       carrot       durian     eggplant  #>    \"3 apple\"   \"5 banana\"   \"1 carrot\"   \"2 durian\" \"4 eggplant\"   future_xmap_vec(list(x, y), ~ .x * .y) #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>  [1] 16  4  8 12 20 20  5 10 15 25  8  2  4  6 10  4  1  2  3  5 12  3  6  9 15 future_xmap_vec(list(fruits, desserts), paste) #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>  [1] \"apple bread\"       \"banana bread\"      \"carrot bread\"      #>  [4] \"durian bread\"      \"eggplant bread\"    \"apple cake\"        #>  [7] \"banana cake\"       \"carrot cake\"       \"durian cake\"       #> [10] \"eggplant cake\"     \"apple cupcake\"     \"banana cupcake\"    #> [13] \"carrot cupcake\"    \"durian cupcake\"    \"eggplant cupcake\"  #> [16] \"apple streudel\"    \"banana streudel\"   \"carrot streudel\"   #> [19] \"durian streudel\"   \"eggplant streudel\" \"apple muffin\"      #> [22] \"banana muffin\"     \"carrot muffin\"     \"durian muffin\"     #> [25] \"eggplant muffin\""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Map over each combination of list elements simultaneously via futures — future_xmap","title":"Map over each combination of list elements simultaneously via futures — future_xmap","text":"functions work exactly xmap() functions, allow run map parallel using future::future()","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map over each combination of list elements simultaneously via futures — future_xmap","text":"","code":"future_xmap(.l, .f, ..., .progress = FALSE, .options = furrr::furrr_options())  future_xmap_chr(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_dbl(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_dfc(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_dfr(   .l,   .f,   ...,   .id = NULL,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_int(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_lgl(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_raw(   .l,   .f,   ...,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xwalk(.l, .f, ..., .progress = FALSE, .options = furrr::furrr_options())"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map over each combination of list elements simultaneously via futures — future_xmap","text":".l list vectors, data frame. length .l determines number arguments .f called . List names used present. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .options future specific options use workers. must result call furrr_options(). .id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map over each combination of list elements simultaneously via futures — future_xmap","text":"atomic vector, list, data frame, depending suffix. Atomic vectors lists named first element .l named. input length 0, output length 0. input length 1, recycled length longest.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map over each combination of list elements simultaneously via futures — future_xmap","text":"","code":"future_xmap(list(1:5, 1:5), ~ .y * .x) #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 2 #>  #> [[7]] #> [1] 4 #>  #> [[8]] #> [1] 6 #>  #> [[9]] #> [1] 8 #>  #> [[10]] #> [1] 10 #>  #> [[11]] #> [1] 3 #>  #> [[12]] #> [1] 6 #>  #> [[13]] #> [1] 9 #>  #> [[14]] #> [1] 12 #>  #> [[15]] #> [1] 15 #>  #> [[16]] #> [1] 4 #>  #> [[17]] #> [1] 8 #>  #> [[18]] #> [1] 12 #>  #> [[19]] #> [1] 16 #>  #> [[20]] #> [1] 20 #>  #> [[21]] #> [1] 5 #>  #> [[22]] #> [1] 10 #>  #> [[23]] #> [1] 15 #>  #> [[24]] #> [1] 20 #>  #> [[25]] #> [1] 25 #>  future_xmap_dbl(list(1:5, 1:5), ~ .y * .x) #> ! `future_xmap_dbl()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>  [1]  1  2  3  4  5  2  4  6  8 10  3  6  9 12 15  4  8 12 16 20  5 10 15 20 25 future_xmap_chr(list(1:5, 1:5), ~ paste(.y, \"*\", .x, \"=\", .y * .x)) #> ! `future_xmap_chr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>  [1] \"1 * 1 = 1\"  \"1 * 2 = 2\"  \"1 * 3 = 3\"  \"1 * 4 = 4\"  \"1 * 5 = 5\"  #>  [6] \"2 * 1 = 2\"  \"2 * 2 = 4\"  \"2 * 3 = 6\"  \"2 * 4 = 8\"  \"2 * 5 = 10\" #> [11] \"3 * 1 = 3\"  \"3 * 2 = 6\"  \"3 * 3 = 9\"  \"3 * 4 = 12\" \"3 * 5 = 15\" #> [16] \"4 * 1 = 4\"  \"4 * 2 = 8\"  \"4 * 3 = 12\" \"4 * 4 = 16\" \"4 * 5 = 20\" #> [21] \"5 * 1 = 5\"  \"5 * 2 = 10\" \"5 * 3 = 15\" \"5 * 4 = 20\" \"5 * 5 = 25\"  apples_and_bananas <- list(   x = c(\"apples\", \"bananas\"),   pattern = \"a\",   replacement = c(\"oo\", \"ee\") )  future_xmap_chr(apples_and_bananas, gsub) #> ! `future_xmap_chr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> [1] \"oopples\"    \"boonoonoos\" \"eepples\"    \"beeneenees\"  formulas <- list(mpg ~ wt, mpg ~ hp) subsets  <- split(mtcars, mtcars$cyl)  future_xmap(list(subsets, formulas), ~ lm(.y, data = .x)) #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> $`4` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>      39.571       -5.647   #>  #>  #> $`6` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>       28.41        -2.78   #>  #>  #> $`8` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>      23.868       -2.192   #>  #>  #> $`4` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>     35.9830      -0.1128   #>  #>  #> $`6` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>   20.673851    -0.007613   #>  #>  #> $`8` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>    18.08007     -0.01424   #>  #>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelized cross map returning a matrix or array — future_xmap_mat","title":"Parallelized cross map returning a matrix or array — future_xmap_mat","text":"Parallelized cross map returning matrix array","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelized cross map returning a matrix or array — future_xmap_mat","text":"","code":"future_xmap_mat(   .l,   .f,   ...,   .names = TRUE,   .progress = FALSE,   .options = furrr::furrr_options() )  future_xmap_arr(   .l,   .f,   ...,   .names = TRUE,   .progress = FALSE,   .options = furrr::furrr_options() )"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelized cross map returning a matrix or array — future_xmap_mat","text":".l list vectors, data frame. length .l determines number arguments .f called . List names used present. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .names logical indicating whether give names dimensions matrix array. inputs named, names used. inputs unnamed, elements input used names. Defaults TRUE. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .options future specific options use workers. must result call furrr_options().","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelized cross map returning a matrix or array — future_xmap_mat","text":"matrix (future_xmap_mat()) array (future_xmap_arr()) dimensions matching lengths input .l.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/future_xmap_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelized cross map returning a matrix or array — future_xmap_mat","text":"","code":"future_xmap_mat(list(1:3, 1:3),  ~ ..1 * ..2) #> ! `future_xmap_mat()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_arr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>   1 2 3 #> 1 1 2 3 #> 2 2 4 6 #> 3 3 6 9  fruits <- c(a = \"apple\", b = \"banana\", c = \"cantaloupe\") future_xmap_mat(list(1:3, fruits), paste) #> ! `future_xmap_mat()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_arr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>   a         b          c              #> 1 \"1 apple\" \"1 banana\" \"1 cantaloupe\" #> 2 \"2 apple\" \"2 banana\" \"2 cantaloupe\" #> 3 \"3 apple\" \"3 banana\" \"3 cantaloupe\" future_xmap_mat(list(1:3, fruits), paste, .names = FALSE) #> ! `future_xmap_mat()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_arr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #>      [,1]      [,2]       [,3]           #> [1,] \"1 apple\" \"1 banana\" \"1 cantaloupe\" #> [2,] \"2 apple\" \"2 banana\" \"2 cantaloupe\" #> [3,] \"3 apple\" \"3 banana\" \"3 cantaloupe\"  future_xmap_arr(list(1:3, 1:3, 1:3),  ~ ..1 * ..2 * ..3) #> ! `future_xmap_arr()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap_vec()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> ! `future_xmap()` is not set up to run background processes. #> • Try running `future::plan(\"multisession\")`. #> ℹ Check ?future::plan() (`?future::plan()`) for more details. #> , , 1 #>  #>   1 2 3 #> 1 1 2 3 #> 2 2 4 6 #> 3 3 6 9 #>  #> , , 2 #>  #>   1  2  3 #> 1 2  4  6 #> 2 4  8 12 #> 3 6 12 18 #>  #> , , 3 #>  #>   1  2  3 #> 1 3  6  9 #> 2 6 12 18 #> 3 9 18 27 #>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/map_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapping functions that automatically determine type — map_vec","title":"Mapping functions that automatically determine type — map_vec","text":"functions work exactly typed variants purrr::map(), purrr::map2(), purrr::pmap(), purrr::imap() xmap() (e.g. purrr::map_chr()), automatically determine type.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/map_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapping functions that automatically determine type — map_vec","text":"","code":"map_vec(.x, .f, ..., .class = NULL)  map2_vec(.x, .y, .f, ..., .class = NULL)  pmap_vec(.l, .f, ..., .class = NULL)  imap_vec(.x, .f, ..., .class = NULL)  xmap_vec(.l, .f, ..., .class = NULL)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/map_vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapping functions that automatically determine type — map_vec","text":".x list atomic vector. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .class .class specified, .y vector length .x. Vectors length 1 recycled. .l list vectors, data frame. length .l determines number arguments .f called . List names used present.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/map_vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapping functions that automatically determine type — map_vec","text":"Equivalent typed variants purrr::map(), purrr::map2(), purrr::pmap(), purrr::imap() xmap() type automatically determined. output contains multiple types, type determined highest type components hierarchy raw < logical < integer < double < complex < character < list (c()). output contains elements coerced vectors (e.g. lists), output list.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/map_vec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mapping functions that automatically determine type — map_vec","text":"","code":"fruits   <- c(\"apple\", \"banana\", \"cantaloupe\", \"durian\", \"eggplant\") desserts <- c(\"bread\", \"cake\", \"cupcake\", \"muffin\", \"streudel\") x        <- sample(5) y        <- sample(5) z        <- sample(5) names(z) <- fruits  map_vec(x, ~ . ^ 2) #> [1]  1 16  4 25  9 map_vec(fruits, paste0, \"s\") #> [1] \"apples\"      \"bananas\"     \"cantaloupes\" \"durians\"     \"eggplants\"    map2_vec(x, y, ~ .x + .y) #> [1] 3 7 7 6 7 map2_vec(fruits, desserts, paste) #> [1] \"apple bread\"        \"banana cake\"        \"cantaloupe cupcake\" #> [4] \"durian muffin\"      \"eggplant streudel\"   pmap_vec(list(x, y, z), sum) #> [1]  5  8 11 11 10 pmap_vec(list(x, fruits, desserts), paste) #> [1] \"1 apple bread\"        \"4 banana cake\"        \"2 cantaloupe cupcake\" #> [4] \"5 durian muffin\"      \"3 eggplant streudel\"   imap_vec(x, ~ .x + .y) #> [1] 2 6 5 9 8 imap_vec(x, ~ paste0(.y, \": \", .x)) #> [1] \"1: 1\" \"2: 4\" \"3: 2\" \"4: 5\" \"5: 3\" imap_vec(z, paste) #>          apple         banana     cantaloupe         durian       eggplant  #>      \"2 apple\"     \"1 banana\" \"4 cantaloupe\"     \"5 durian\"   \"3 eggplant\"   xmap_vec(list(x, y), ~ .x * .y) #>  [1]  2  8  4 10  6  3 12  6 15  9  5 20 10 25 15  1  4  2  5  3  4 16  8 20 12 xmap_vec(list(fruits, desserts), paste) #>  [1] \"apple bread\"         \"banana bread\"        \"cantaloupe bread\"    #>  [4] \"durian bread\"        \"eggplant bread\"      \"apple cake\"          #>  [7] \"banana cake\"         \"cantaloupe cake\"     \"durian cake\"         #> [10] \"eggplant cake\"       \"apple cupcake\"       \"banana cupcake\"      #> [13] \"cantaloupe cupcake\"  \"durian cupcake\"      \"eggplant cupcake\"    #> [16] \"apple muffin\"        \"banana muffin\"       \"cantaloupe muffin\"   #> [19] \"durian muffin\"       \"eggplant muffin\"     \"apple streudel\"      #> [22] \"banana streudel\"     \"cantaloupe streudel\" \"durian streudel\"     #> [25] \"eggplant streudel\""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/tidy_glance.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn an object into a tidy tibble with glance information — tidy_glance","title":"Turn an object into a tidy tibble with glance information — tidy_glance","text":"Apply generics::tidy() generics::glance() object return single tibble sets information.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/tidy_glance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn an object into a tidy tibble with glance information — tidy_glance","text":"","code":"tidy_glance(x, ..., tidy_args = list(), glance_args = list())"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/tidy_glance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn an object into a tidy tibble with glance information — tidy_glance","text":"x object converted tidy tibble. ... Additional arguments passed generics::tidy() generics::glance(). Arguments passed methods, ignored inapplicable method. example, called lm object, conf.int affect generics::tidy() generics::glance(). tidy_args list additional arguments passed generics::tidy(). glance_args list additional arguments passed generics::glance().","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/tidy_glance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn an object into a tidy tibble with glance information — tidy_glance","text":"tibble columns rows generics::tidy() columns repeated rows generics::glance(). Column names appear tidy data glance data disambiguated appending \"model.\" glance column names.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/tidy_glance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn an object into a tidy tibble with glance information — tidy_glance","text":"","code":"mod <- lm(mpg ~ wt + qsec, data = mtcars) tidy_glance(mod) #> # A tibble: 3 × 17 #>   term       estimate std.error statistic  p.value r.squared adj.r.squared sigma #>   <chr>         <dbl>     <dbl>     <dbl>    <dbl>     <dbl>         <dbl> <dbl> #> 1 (Intercep…   19.7       5.25       3.76 7.65e- 4     0.826         0.814  2.60 #> 2 wt           -5.05      0.484    -10.4  2.52e-11     0.826         0.814  2.60 #> 3 qsec          0.929     0.265      3.51 1.50e- 3     0.826         0.814  2.60 #> # ℹ 9 more variables: model.statistic <dbl>, model.p.value <dbl>, df <dbl>, #> #   logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>, #> #   nobs <int> tidy_glance(mod, conf.int = TRUE) #> # A tibble: 3 × 19 #>   term        estimate std.error statistic  p.value conf.low conf.high r.squared #>   <chr>          <dbl>     <dbl>     <dbl>    <dbl>    <dbl>     <dbl>     <dbl> #> 1 (Intercept)   19.7       5.25       3.76 7.65e- 4    9.00      30.5      0.826 #> 2 wt            -5.05      0.484    -10.4  2.52e-11   -6.04      -4.06     0.826 #> 3 qsec           0.929     0.265      3.51 1.50e- 3    0.387      1.47     0.826 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int> tidy_glance(mod, tidy_args = list(conf.int = TRUE)) #> # A tibble: 3 × 19 #>   term        estimate std.error statistic  p.value conf.low conf.high r.squared #>   <chr>          <dbl>     <dbl>     <dbl>    <dbl>    <dbl>     <dbl>     <dbl> #> 1 (Intercept)   19.7       5.25       3.76 7.65e- 4    9.00      30.5      0.826 #> 2 wt            -5.05      0.484    -10.4  2.52e-11   -6.04      -4.06     0.826 #> 3 qsec           0.929     0.265      3.51 1.50e- 3    0.387      1.47     0.826 #> # ℹ 11 more variables: adj.r.squared <dbl>, sigma <dbl>, model.statistic <dbl>, #> #   model.p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>, #> #   deviance <dbl>, df.residual <int>, nobs <int>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Map over each combination of list elements — xmap","title":"Map over each combination of list elements — xmap","text":"functions variants purrr::pmap() iterate combination elements list.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map over each combination of list elements — xmap","text":"","code":"xmap(.l, .f, ...)  xmap_chr(.l, .f, ...)  xmap_dbl(.l, .f, ...)  xmap_dfc(.l, .f, ...)  xmap_dfr(.l, .f, ..., .id = NULL)  xmap_int(.l, .f, ...)  xmap_lgl(.l, .f, ...)  xmap_raw(.l, .f, ...)  xwalk(.l, .f, ...)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map over each combination of list elements — xmap","text":".l list vectors, data frame. length .l determines number arguments .f called . List names used present. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map over each combination of list elements — xmap","text":"atomic vector, list, data frame, depending suffix. Atomic vectors lists named first element .l named. input length 0, output length 0. input length 1, recycled length longest.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map over each combination of list elements — xmap","text":"Typed variants return vector specified type. automatically determine type, try xmap_vec(). return results matrix array, try xmap_mat() xmap_arr(). Note data frame important special case, case xmap() xwalk() apply function .f row. xmap_dfr() xmap_dfc() return data frames created row-binding column-binding respectively.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map over each combination of list elements — xmap","text":"","code":"xmap(list(1:5, 1:5), ~ .y * .x) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 2 #>  #> [[7]] #> [1] 4 #>  #> [[8]] #> [1] 6 #>  #> [[9]] #> [1] 8 #>  #> [[10]] #> [1] 10 #>  #> [[11]] #> [1] 3 #>  #> [[12]] #> [1] 6 #>  #> [[13]] #> [1] 9 #>  #> [[14]] #> [1] 12 #>  #> [[15]] #> [1] 15 #>  #> [[16]] #> [1] 4 #>  #> [[17]] #> [1] 8 #>  #> [[18]] #> [1] 12 #>  #> [[19]] #> [1] 16 #>  #> [[20]] #> [1] 20 #>  #> [[21]] #> [1] 5 #>  #> [[22]] #> [1] 10 #>  #> [[23]] #> [1] 15 #>  #> [[24]] #> [1] 20 #>  #> [[25]] #> [1] 25 #>  xmap_dbl(list(1:5, 1:5), ~ .y * .x) #>  [1]  1  2  3  4  5  2  4  6  8 10  3  6  9 12 15  4  8 12 16 20  5 10 15 20 25 xmap_chr(list(1:5, 1:5), ~ paste(.y, \"*\", .x, \"=\", .y * .x)) #>  [1] \"1 * 1 = 1\"  \"1 * 2 = 2\"  \"1 * 3 = 3\"  \"1 * 4 = 4\"  \"1 * 5 = 5\"  #>  [6] \"2 * 1 = 2\"  \"2 * 2 = 4\"  \"2 * 3 = 6\"  \"2 * 4 = 8\"  \"2 * 5 = 10\" #> [11] \"3 * 1 = 3\"  \"3 * 2 = 6\"  \"3 * 3 = 9\"  \"3 * 4 = 12\" \"3 * 5 = 15\" #> [16] \"4 * 1 = 4\"  \"4 * 2 = 8\"  \"4 * 3 = 12\" \"4 * 4 = 16\" \"4 * 5 = 20\" #> [21] \"5 * 1 = 5\"  \"5 * 2 = 10\" \"5 * 3 = 15\" \"5 * 4 = 20\" \"5 * 5 = 25\"  apples_and_bananas <- list(   x = c(\"apples\", \"bananas\"),   pattern = \"a\",   replacement = c(\"oo\", \"ee\") )  xmap_chr(apples_and_bananas, gsub) #> [1] \"oopples\"    \"boonoonoos\" \"eepples\"    \"beeneenees\"  formulas <- list(mpg ~ wt, mpg ~ hp) subsets  <- split(mtcars, mtcars$cyl)  xmap(list(subsets, formulas), ~ lm(.y, data = .x)) #> $`4` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>      39.571       -5.647   #>  #>  #> $`6` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>       28.41        -2.78   #>  #>  #> $`8` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           wt   #>      23.868       -2.192   #>  #>  #> $`4` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>     35.9830      -0.1128   #>  #>  #> $`6` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>   20.673851    -0.007613   #>  #>  #> $`8` #>  #> Call: #> lm(formula = .y, data = .x) #>  #> Coefficients: #> (Intercept)           hp   #>    18.08007     -0.01424   #>  #>  xmap(list(data = subsets, formula = formulas), lm) #> $`4` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           wt   #>      39.571       -5.647   #>  #>  #> $`6` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           wt   #>       28.41        -2.78   #>  #>  #> $`8` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           wt   #>      23.868       -2.192   #>  #>  #> $`4` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           hp   #>     35.9830      -0.1128   #>  #>  #> $`6` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           hp   #>   20.673851    -0.007613   #>  #>  #> $`8` #>  #> Call: #> .f(formula = .l[[2L]][[i]], data = .l[[1L]][[i]]) #>  #> Coefficients: #> (Intercept)           hp   #>    18.08007     -0.01424   #>  #>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a table applying a function to all combinations of list elements — xmap_mat","title":"Return a table applying a function to all combinations of list elements — xmap_mat","text":"Return table applying function combinations list elements","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a table applying a function to all combinations of list elements — xmap_mat","text":"","code":"xmap_mat(.l, .f, ..., .names = TRUE)  xmap_arr(.l, .f, ..., .names = TRUE)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return a table applying a function to all combinations of list elements — xmap_mat","text":".l list vectors, data frame. length .l determines number arguments .f called . List names used present. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed .f .names logical indicating whether give names dimensions matrix array. inputs named, names used. inputs unnamed, elements input used names. Defaults TRUE.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return a table applying a function to all combinations of list elements — xmap_mat","text":"matrix (xmap_mat()) array (xmap_arr()) dimensions equal lengths input .l.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xmap_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return a table applying a function to all combinations of list elements — xmap_mat","text":"","code":"xmap_mat(list(1:3, 1:3),  ~ ..1 * ..2) #>   1 2 3 #> 1 1 2 3 #> 2 2 4 6 #> 3 3 6 9  fruits <- c(a = \"apple\", b = \"banana\", c = \"cantaloupe\") xmap_mat(list(1:3, fruits), paste) #>   a         b          c              #> 1 \"1 apple\" \"1 banana\" \"1 cantaloupe\" #> 2 \"2 apple\" \"2 banana\" \"2 cantaloupe\" #> 3 \"3 apple\" \"3 banana\" \"3 cantaloupe\" xmap_mat(list(1:3, fruits), paste, .names = FALSE) #>      [,1]      [,2]       [,3]           #> [1,] \"1 apple\" \"1 banana\" \"1 cantaloupe\" #> [2,] \"2 apple\" \"2 banana\" \"2 cantaloupe\" #> [3,] \"3 apple\" \"3 banana\" \"3 cantaloupe\"  xmap_arr(list(1:3, 1:3, 1:3),  ~ ..1 * ..2 * ..3) #> , , 1 #>  #>   1 2 3 #> 1 1 2 3 #> 2 2 4 6 #> 3 3 6 9 #>  #> , , 2 #>  #>   1  2  3 #> 1 2  4  6 #> 2 4  8 12 #> 3 6 12 18 #>  #> , , 3 #>  #>   1  2  3 #> 1 3  6  9 #> 2 6 12 18 #> 3 9 18 27 #>"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xpluck.html","id":null,"dir":"Reference","previous_headings":"","what":"Get one or more elements deep within a nested data structure — xpluck","title":"Get one or more elements deep within a nested data structure — xpluck","text":"xpluck() provides alternative purrr::pluck(). Unlike purrr::pluck(), xpluck() allows extract multiple indices nesting level.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xpluck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get one or more elements deep within a nested data structure — xpluck","text":"","code":"xpluck(.x, ..., .default = NULL)"},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xpluck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get one or more elements deep within a nested data structure — xpluck","text":".x list vector ... list accessors indexing object. Can positive integers, negative integers (index right), strings (index names) missing (keep elements given level). Unlike purrr::pluck(), accessor may vector extract multiple elements. accessor length 0 (e.g. NULL, character(0) numeric(0)), xpluck() return NULL. .default Value use target NULL absent.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xpluck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get one or more elements deep within a nested data structure — xpluck","text":"list vector.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/reference/xpluck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get one or more elements deep within a nested data structure — xpluck","text":"","code":"obj1 <- list(\"a\", list(1, elt = \"foo\")) obj2 <- list(\"b\", list(2, elt = \"bar\")) x <- list(obj1, obj2)  xpluck(x, 1:2, 2) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]]$elt #> [1] \"foo\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 2 #>  #> [[2]]$elt #> [1] \"bar\" #>  #>  xpluck(x, , 2) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]]$elt #> [1] \"foo\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 2 #>  #> [[2]]$elt #> [1] \"bar\" #>  #>   xpluck(x, , 2, 1) #> [1] 1 2 xpluck(x, , 2, 2) #> [1] \"foo\" \"bar\" xpluck(x, , 2, 1:2) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] \"foo\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 2 #>  #> [[2]][[2]] #> [1] \"bar\" #>  #>"},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-042","dir":"Changelog","previous_headings":"","what":"crossmap 0.4.2","title":"crossmap 0.4.2","text":"CRAN release: 2025-04-25 Skip testing future functions CRAN avoid issues.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-041","dir":"Changelog","previous_headings":"","what":"crossmap 0.4.1","title":"crossmap 0.4.1","text":"CRAN release: 2025-04-21 Non-user-facing changes fix test failures.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-040","dir":"Changelog","previous_headings":"","what":"crossmap 0.4.0","title":"crossmap 0.4.0","text":"CRAN release: 2023-01-12 xpluck() works like purrr::pluck(), allows specify multiple indices step, e.g. xpluck(x, 1:2, c(\"\", \"b\")). purrr::map_raw() *_raw() functions deprecated purrr 1.0.0.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-033","dir":"Changelog","previous_headings":"","what":"crossmap 0.3.3","title":"crossmap 0.3.3","text":"CRAN release: 2022-08-12 Update roxygen version avoid CRAN NOTE. Remove broomExtra suggested packages, archived CRAN.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"new-features-0-3-2","dir":"Changelog","previous_headings":"","what":"New features","title":"crossmap 0.3.2","text":"map_vec() family functions gain .class argument, coerces element output given class.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"enhancements-0-3-2","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"crossmap 0.3.2","text":"map_vec() family functions can now return vectors S3 classes addition base classes. broom broomExtra now Suggested packages.","code":""},{"path":[]},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"","what":"New features","title":"crossmap 0.3.1","text":"cross_fit() gains argument clusters, allowing mapping along cluster specifications functions support , like estimatr::lm_robust(). cross_fit_robust() wrapper cross_fit(fn = estimatr::lm_robust).","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"enhancements-0-3-1","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"crossmap 0.3.1","text":"tidy_glance() (functions call ) now use broomExtra instead broom support model types. Functions now use rlang::check_installed() suggested packages, giving user option install package interactively.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"miscellaneous-0-3-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"crossmap 0.3.1","text":"Use cli generate error messages. Move stats suggested imported packages.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-030","dir":"Changelog","previous_headings":"","what":"crossmap 0.3.0","title":"crossmap 0.3.0","text":"CRAN release: 2021-04-02","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"crossmap 0.3.0","text":"Added cross_fit_glm(), works like cross_fit() allows also specify crossing glm() model families. Added tidy_glance(), returns tibble information broom::tidy() broom::glance(). tidy_glance() now default tidier cross_fit(). Added future_xmap_raw() future_xwalk().","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"patches-0-3-0","dir":"Changelog","previous_headings":"","what":"Patches","title":"crossmap 0.3.0","text":"cross_join(), cross_list(), cross_tbl() cross_df() now silently ignore NULL inputs. future_*() functions now prompt user select future plan R set parallelization.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"miscellaneous-0-3-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"crossmap 0.3.0","text":"Promoted broom dplyr suggested imported packages.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-020","dir":"Changelog","previous_headings":"","what":"crossmap 0.2.0","title":"crossmap 0.2.0","text":"CRAN release: 2020-09-24","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"crossmap 0.2.0","text":"can now cross model specifications three dimensions: formulas, subsets, weights. Weights specified list column names, NULL NA unweighted model.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"miscellaneous-0-2-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"crossmap 0.2.0","text":"Added tibble suggested package. Added NEWS.md file track changes package. Added URL pkgdown YAML.","code":""},{"path":"https://pkg.rossellhayes.com/crossmap/news/index.html","id":"crossmap-010","dir":"Changelog","previous_headings":"","what":"crossmap 0.1.0","title":"crossmap 0.1.0","text":"CRAN release: 2020-09-10 Initial CRAN release.","code":""}]
